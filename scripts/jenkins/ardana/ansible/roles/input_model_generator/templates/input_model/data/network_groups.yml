#
# (c) Copyright 2018 SUSE LLC
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.
#
---
  product:
    version: 2

  network-groups:

{% set ns = namespace(physnet_id=0, extnet_id=0, routes=[]) %}
{% for network_group in scenario['network_groups'] %}

    - name: {{ network_group.name|upper }}
      hostname-suffix: {{ network_group['hostname_suffix'] }}
{%   if 'MANAGEMENT' in network_group['component_endpoints'] %}
      # We use the MANAGEMENT network to derive server hostnames
      hostname: true
      tls-component-endpoints:
        # The following service endpoints are behind TLS
        - barbican-api
        - mysql
        - rabbitmq
{%   endif %}
      component-endpoints:
{%   if 'MANAGEMENT' in network_group['component_endpoints'] %}

        #
        # Management
        #
        # This is the network group that will be used to for
        # management traffic within the cloud. It is used
        # as a default by all component-endpoints.
        - default

{%   elif 'CLM' in network_group['component_endpoints'] %}

        #
        # CLM
        #
        # This is the network group that will be used to
        # provision the OS onto the nodes and to perform
        # the inital OS configuration
        #
        - lifecycle-manager
        - lifecycle-manager-target
{%   elif 'SWIFT' in network_group['component_endpoints'] %}

        #
        # SWIFT
        #
        # This is the network group that will be used for
        # Swift back-end traffic between proxy, container, account
        # and object servers
        #
        - swift-container
        - swift-account
        - swift-object
        - swift-rsync
{%   elif 'EXTERNAL-API' in network_group.component_endpoints %}
        - {{ designate_backend }}-ext
{%   else %}
        []
{%   endif %}

{%   set ns.routes=network_group.routes|default([]) %}
{%   if 'MANAGEMENT' in network_group.component_endpoints %}
{%     if bm_info is defined %}
{%       set _ = ns.routes.append('OCTAVIA-MGMT-NET') %}
{%       set _ = ns.routes.append('ILO') %}
{%     else %}
{%       for neutron_ng in scenario.network_groups if 'NEUTRON-VLAN' in neutron_ng.component_endpoints %}
{%         set _ = ns.routes.append('NEUTRON-%s-VLAN-NET'|format(neutron_ng.name|upper)) %}
{%       endfor  %}
{%     endif %}
{%   endif %}

{%   if ns.routes %}
      routes:
{%     for route in ns.routes %}
        - {{ route }}
{%     endfor  %}
{%   endif %}

{% if network_group.name != 'ILO' %}
      load-balancers:
{%   if 'INTERNAL-API' in network_group['component_endpoints'] %}

        #
        # Internal API
        #
        # This is the network group that services will use to
        # access the internal API endpoints of your cloud
        #

        - provider: ip-cluster
          name: internal-lb
          tls-components:
            - default
          components:
          # These services do not currently support TLS
            - nova-metadata
          roles:
            - internal
            - admin
          cert-file: ardana-internal-cert
          # The ardana-internal-cert is a reserved name and
          # this certificate will be autogenerated. Customer
          # can bring in their own cert with a different name
          # and follow the process described for the external
          # loadbalancer configuration above. See under
          # my-public-mid-scale-kvm-cert.
          # It is important to use the request
          # template generated by the config processor as there
          # are more Subject Alt-name entries for the internal
          # certificate than the external certificate.
{%   elif 'EXTERNAL-API' in network_group['component_endpoints'] %}

        #
        # External API
        #
        # This is the network group that users will use to
        # access the public API endpoints of your cloud
        #

        - provider: ip-cluster
          name: external-lb
          # If external-name is set then public urls in keystone
          # will use this name instead of the IP address
          #You must either set this to a name that can be resolved in your network
          # or comment out this line to use IP addresses
          external-name: {{ external_name | default('') }}
          tls-components:
            - default
          roles:
            - public
          cert-file: my-public-{{ scenario['cloud_name'] }}-cert
          # This is the name of the certificate that will be used on load balancer.
          # Ardana will look for a file with this name in the config/tls/certs directory.
          # This is the certificate that matches your setting for external-name
          #
          # Note that it is also possible to have per service certificates:
          #
          # cert-file:
          # default: my-public-mid-scale-kvm-cert
          # horizon: my-horizon-cert
          # nova-api: my-nova-cert
          #
          # The configuration-processor will also create a request templates for each
          # named certificates under
          # "info/cert_reqs/"
          #
          # And this will be of the form
          #
          # info/cert_reqs/my-public-mid-scale-kvm-cert
          # info/cert_reqs/my-horizon-cert
          # info/cert_reqs/my-nova-cert
          #
          # These request templates contain the subject Alt-names that
          # the certificates need. A customer can add to this template
          # before generating their Certificate Signing Request (CSR).
          # They would then send the CSR to their CA to be signed and
          # receive the certificate, which can then be dropped into
          # "config/tls/certs".
          #
          # When you bring in your own certificate you may want to bring
          # in the trust chains (or CA certificate) for this certificate.
          # This is usually not required if the CA is a public signer that
          # gets bundled by the system. However, we suggest you include it
          # into Ardana anyway by copying the file into the directory
          # "config/cacerts/".
          # Note that the file extension should be .crt or it will not
          # be processed by Ardana.
{%   else %}
        []
{%   endif %}
{%   if 'NEUTRON-EXT' in network_group['component_endpoints'] or
        'NEUTRON-VLAN' in network_group['component_endpoints'] or
        'NEUTRON-VXLAN' in network_group['component_endpoints'] %}
      tags:
{%     if 'NEUTRON-EXT' in network_group['component_endpoints'] %}
        #
        # Neutron external VM
        #
        # This is the network group that will be used to provide
        # external access to VMs (via floating IP Addresses)
        #
{%       if enable_external_network_bridge %}
        - neutron.l3_agent.external_network_bridge
{%       else %}
        - neutron.networks.flat:
            provider-physical-network: external{{ ns.extnet_id | ternary(ns.extnet_id, '') }}
{%         set ns.extnet_id = ns.extnet_id+1 %}
{%       endif %}
{%     endif %}
{%     if 'NEUTRON-VLAN' in network_group['component_endpoints'] %}
{%       set ns.physnet_id = ns.physnet_id+1 %}
        # The interface used by this group will be presented
        # to Neutron as physnet{{ ns.physnet_id }}, and used by provider VLANS
        #
        #
        - neutron.networks.vlan:
            provider-physical-network: physnet{{ ns.physnet_id }}

{%     endif %}
{%     if 'NEUTRON-VXLAN' in network_group['component_endpoints'] %}
        #
        # Neutron guest VXLAN
        #
        # This is the network group that will be used to provide
        # VXLAN encapsulated private networks to VMs
        #
        - neutron.networks.vxlan

        # To specify a specific set of vxlan IDs change the above to
        #  - neutron.networks.vxlan:
        #      tenant-vxlan-id-range: "1000:2000,3000:3500"
{%     endif %}
{%   else %}
      tags: []
{%   endif %}
{% endif %}
{% endfor %}
